import fcl

from pymesh import Mesh
from scipy.spatial import distance
import sys

sys.path.append("/home/tristan/projects:/home/tristan/projects/cell_decomposition_py")
sys.path.append("/home/tristan/projects/cell_decomposition_py/org")
sys.path.append("/home/tristan/projects/cell_decomposition_py/org/combinators")

from combinators.ctp.py.celldecomposition.scene_object import *


class Scene:
    def get_scene_mesh_3d(self):
        current_mesh = self.get_scene_boundaries_3d_pym()
        for i in self.scene_objects:
            current_mesh = pymesh.boolean(current_mesh, i.to_pymesh(), operation="difference")
        return current_mesh

    @staticmethod  # Boundary is AABB
    def get_scene_boundaries_3d():
        return np.array([[-5, 5], [-5, 5], [-5, 5]])

    @staticmethod
    def get_scene_boundaries_2d():
        return (lambda x: [x[0], x[1]])(Scene.get_scene_boundaries_3d())

    @staticmethod
    def get_scene_boundaries_2d_pym():
        ar = Scene.get_scene_boundaries_2d()
        x_min, x_max = ar[0][0], ar[0][1]
        y_min, y_max = ar[1][0], ar[1][1]
        faces = [[0, 1, 3],
                 [1, 2, 3]]
        return pymesh.form_mesh(np.array(
            [[x_min, y_min],
             [x_max, y_min],
             [x_max, y_max],
             [x_min, y_max]]),
            np.array(faces))

    @staticmethod
    def get_scene_boundaries_3d_pym():
        ar = Scene.get_scene_boundaries_3d()
        return pymesh.generate_box_mesh(np.array([ar[0][0], ar[1][0], ar[2][0]]),
                                        np.array([ar[0][1], ar[1][1], ar[2][1]]), using_simplex=True)

    @staticmethod
    def get_top_boundary_2d():
        return (lambda x: x[1][1])(Scene.get_scene_boundaries_3d())

    @staticmethod
    def get_bottom_boundary_2d():
        return (lambda x: x[1][0])(Scene.get_scene_boundaries_3d())

    @property
    def scene_objects(self):
        return self._scene_objects

    @property
    def dimensionality(self):
        return self._dimensionality

    @dimensionality.setter
    def dimensionality(self, value):
        self._dimensionality = value

    @scene_objects.setter
    def scene_objects(self, value):
        self._scene_objects = value

    # def get_objects_test(self):
    #     for i in self.geometry.values():
    #         print(f"isBox: {isinstance(i, fcl.Box)}")
    #         print(f"isBVHModel: {isinstance(i, fcl.BVHModel)}")

    def export_model(self):
        scene_mesh = self.transform_to_pymesh()
        pymesh.save_mesh("/home/tristan/projects/cell_decomposition_py/resources/scene_mesh_out.obj", scene_mesh)
        #print(f"Saved model to /home/tristan/projects/cell_decomposition_py/resources/scene_mesh_out.obj")

    def transform_to_pymesh(self):
        output_mesh = self.get_scene_boundaries_3d_pym()
        for o in self.scene_objects:
            output_mesh = pymesh.boolean(output_mesh, o.to_pymesh(), operation="difference")
        return output_mesh

    @staticmethod
    def mesh_to_graph_3d(m: Mesh):
        center_points = np.array([k.mean(axis=0) for k in (m.vertices[i] for i in m.voxels)])  # TODO too many
        weighted_edges = Scene.find_neighbor_weights(m, center_points)
        print(f"weighted_edges: {weighted_edges}")
        pymesh.save_mesh("/home/tristan/projects/cell_decomposition_py/resources/mesh_to_graph_test.msh", m)

    @staticmethod
    def mesh_to_graph_2d(m: Mesh):
        center_points = np.array([k.mean(axis=0) for k in (m.vertices[i] for i in m.faces)])  # TODO test
        weighted_edges = Scene.find_neighbor_weights(m, center_points)
        print(f"weighted_edges: {weighted_edges}")
        pymesh.save_mesh("/home/tristan/projects/cell_decomposition_py/resources/mesh_to_graph_test.msh", m)

    @staticmethod
    def voxel_distance(v1: np.array, v2: np.array):
        return distance.euclidean(v1, v2)

    @staticmethod
    def cells_are_neighbours(v1, v2):
        print(f"vertices: v1: {v1}, v2: {v2}")
        print(f"vertices_are_neighbours: {v1} ---  {v2}: {np.intersect1d(v1, v2).shape[0] == 3}")
        return np.intersect1d(v1, v2).shape[0] == 3

    @staticmethod
    def find_neighbor_weights(m: Mesh, center_points):
        assert (len(m.vertices) == len(np.unique(m.vertices, axis=1)))
        assert len(m.voxels) == len(center_points)

        neighbours = ((x, y) for x in range(len(m.voxels)) for y in range(len(m.voxels)) if
                      Scene.cells_are_neighbours(m.voxels[x], m.voxels[y]))
        gen_expression_2 = [(v1, v2, Scene.voxel_distance(center_points[v1], center_points[v2])) for v1, v2 in neighbours]

        return np.array(gen_expression_2)


class Scene3D(Scene):
    @staticmethod
    def get_3d_example_mesh():
        verts = np.array([[0.0, 0.0, 0.0],
                          [1.0, 0.0, 0.0],
                          [0.0, 1.0, 0.0],
                          [0.0, 0.0, 1.0]])
        tris = np.array([[0, 2, 1],
                         [0, 3, 2],
                         [0, 1, 3],
                         [1, 2, 3]])
        return verts, tris

    def __init__(self):
        self.dimensionality = 3
$substitute$


class Scene2D(Scene):
    def __init__(self):
        t_mat = np.array([[0.9, -0.1],
                          [0.1, 0.9]])
        transformed_box = SceneObjectBox2d(2, 1.5)
        transformed_box.translate_2d([-2, 1.5])
        print(transformed_box.vertices)
        transformed_box.transform(t_mat)
        foo21 = SceneObjectBox2d(1, 1)
        foo21.transform(-t_mat)
        foo3 = get_standard_polygon_so()
        foo3.translate_2d([1, 2])
        self.dimensionality = 2
        self.scene_objects = [foo21, transformed_box, foo3]
